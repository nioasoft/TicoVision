---
phase: 04-real-time-message-delivery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/modules/annual-balance/services/balance-chat.service.ts
  - src/modules/annual-balance/components/BalanceChatSheet.tsx
autonomous: true

must_haves:
  truths:
    - "When user A sends a message, user B sees it appear in their open chat panel within 2 seconds without refreshing"
    - "Real-time subscription is created when chat panel opens and cleaned up when panel closes"
    - "Messages arrive in chronological order even when multiple users send simultaneously"
    - "Duplicate messages do not appear when reconnecting or from optimistic send + Realtime race"
  artifacts:
    - path: "src/modules/annual-balance/services/balance-chat.service.ts"
      provides: "subscribeToBalanceChat() method returning RealtimeChannel"
      contains: "subscribeToBalanceChat"
    - path: "src/modules/annual-balance/components/BalanceChatSheet.tsx"
      provides: "Realtime subscription lifecycle tied to sheet open/close"
      contains: "removeChannel"
  key_links:
    - from: "src/modules/annual-balance/components/BalanceChatSheet.tsx"
      to: "src/modules/annual-balance/services/balance-chat.service.ts"
      via: "balanceChatService.subscribeToBalanceChat() called in useEffect"
      pattern: "balanceChatService\\.subscribeToBalanceChat"
    - from: "src/modules/annual-balance/services/balance-chat.service.ts"
      to: "supabase.channel().on('postgres_changes')"
      via: "Supabase Realtime postgres_changes subscription on balance_chat_messages"
      pattern: "postgres_changes.*balance_chat_messages"
---

<objective>
Add real-time message delivery to the balance chat so that when one user sends a message, all other users with the same chat panel open see it appear instantly without page refresh.

Purpose: Currently messages only appear after manual refresh. Real-time delivery is critical for a chat experience -- users expect instant message appearance.

Output: Modified service with subscription method + modified Sheet with Realtime lifecycle, deduplication, and sender enrichment for incoming messages.
</objective>

<execution_context>
@/Users/asafbenatia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/asafbenatia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-real-time-message-delivery/04-RESEARCH.md
@.planning/phases/02-chat-service-layer/02-01-SUMMARY.md
@.planning/phases/03-chat-ui-components/03-01-SUMMARY.md

# Existing Realtime pattern to follow:
@src/modules/chat/services/chat.service.ts (lines 166-185 — subscribeToMessages pattern)
@src/modules/chat/components/ChatPanel.tsx (lines 28-53 — subscription lifecycle + cleanup)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add subscribeToBalanceChat method to BalanceChatService</name>
  <files>src/modules/annual-balance/services/balance-chat.service.ts</files>
  <action>
Add a new `subscribeToBalanceChat()` method to the `BalanceChatService` class, before the closing brace. Follow the exact pattern from `src/modules/chat/services/chat.service.ts` lines 166-185 (`subscribeToMessages`).

Method signature:
```typescript
subscribeToBalanceChat(
  tenantId: string,
  balanceId: string,
  onMessage: (message: BalanceChatMessageRow) => void
)
```

Implementation details:
1. Channel name: `balance-chat:${tenantId}:${balanceId}` — namespaced by both tenant AND balance for uniqueness
2. Use `supabase.channel(channelName).on('postgres_changes', config, callback).subscribe()`
3. postgres_changes config:
   - `event: 'INSERT'` (only new messages, not updates)
   - `schema: 'public'`
   - `table: 'balance_chat_messages'`
   - `filter: \`tenant_id=eq.${tenantId}\`` — single-column server-side filter (multi-column NOT supported by Supabase Realtime)
4. In the callback:
   - Cast `payload.new` as `BalanceChatMessageRow`
   - Client-side filter: `if (newMsg.balance_id === balanceId && !newMsg.is_deleted)` — then call `onMessage(newMsg)`
5. Return the channel object directly (caller uses it for cleanup via `supabase.removeChannel()`)

Add JSDoc comment explaining: purpose, parameter descriptions, the single-column filter constraint, and that cleanup is via `supabase.removeChannel(returnValue)`.

Do NOT create a Zustand store. The service method returns raw `BalanceChatMessageRow` (not enriched) — the component handles enrichment.
  </action>
  <verify>
Run `npm run typecheck` from project root — must pass with 0 errors. Grep the file for `subscribeToBalanceChat` to confirm the method exists. Verify it imports nothing new (supabase singleton already imported).
  </verify>
  <done>
BalanceChatService has a `subscribeToBalanceChat(tenantId, balanceId, onMessage)` method that creates a Supabase Realtime channel with postgres_changes INSERT listener on balance_chat_messages, filtered by tenant_id server-side and balance_id client-side, and returns the channel for cleanup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Realtime subscription lifecycle to BalanceChatSheet</name>
  <files>src/modules/annual-balance/components/BalanceChatSheet.tsx</files>
  <action>
Modify `BalanceChatSheet.tsx` to subscribe to real-time messages when the Sheet opens and clean up when it closes. Follow the pattern from `src/modules/chat/components/ChatPanel.tsx` lines 28-53.

**Step 1: Add imports**
- Add `useRef` to the React imports (alongside existing useState, useEffect, useCallback)
- Add `supabase` import: `import { supabase } from '@/lib/supabase'`
- Add `BalanceChatMessageRow` to the type import from `../types/balance-chat.types` (alongside existing BalanceChatMessageWithSender)

**Step 2: Add userMap ref**
After the existing `const [loading, setLoading] = useState(false);` line, add:
```typescript
const userMapRef = useRef<Map<string, { name: string; email: string }>>(new Map());
```
This stores sender info for enriching Realtime messages. Using ref (not state) because it's lookup data, not rendered state.

**Step 3: Build userMap in the existing fetch useEffect**
In the existing `fetchMessages` function, after `setMessages(result.data ?? [])`, add code to build the userMap from the fetched enriched messages:
```typescript
// Build user map for Realtime message enrichment
const map = new Map<string, { name: string; email: string }>();
for (const msg of result.data ?? []) {
  if (!map.has(msg.user_id)) {
    map.set(msg.user_id, { name: msg.sender_name, email: msg.sender_email });
  }
}
userMapRef.current = map;
```
Also add the current user to the map (so their own Realtime messages can be enriched):
```typescript
if (user) {
  map.set(user.id, {
    name: (user.user_metadata?.full_name as string) || user.email || '',
    email: user.email || '',
  });
}
```

**Step 4: Create handleRealtimeMessage callback**
After the existing `handleSend` callback, add:
```typescript
const handleRealtimeMessage = useCallback((rawMsg: BalanceChatMessageRow) => {
  setMessages(prev => {
    // Dedup: skip if message ID already exists (from optimistic send replacement or reconnection)
    if (prev.some(m => m.id === rawMsg.id)) {
      return prev;
    }

    // Enrich with sender info from userMap
    const sender = userMapRef.current.get(rawMsg.user_id);
    const enriched: BalanceChatMessageWithSender = {
      ...rawMsg,
      sender_name: sender?.name ?? 'משתמש',
      sender_email: sender?.email ?? '',
    };

    return [...prev, enriched];
  });
}, []);
```

Key dedup logic: The optimistic send flow in `handleSend` works as follows:
1. Optimistic message added with temp ID (crypto.randomUUID())
2. Server response replaces optimistic with real data (real server ID now in state)
3. Realtime INSERT arrives with same real server ID -> `prev.some(m => m.id === rawMsg.id)` catches it -> returns prev (no duplicate)

Race condition (Realtime arrives BEFORE sendMessage response):
- Realtime message gets added (server ID not matching temp ID -> passes dedup)
- Then sendMessage response replaces temp ID message with server data -> now two copies exist
- Mitigation: add a secondary dedup pass in the sendMessage success path. In the `handleSend` callback, change the optimistic replacement line from:
  ```
  setMessages(prev => prev.map(m => m.id === optimisticMsg.id ? result.data! : m));
  ```
  to:
  ```
  setMessages(prev => {
    // Replace optimistic message and remove any Realtime duplicate
    const withoutDupes = prev.filter(m => m.id !== optimisticMsg.id && m.id !== result.data!.id);
    return [...withoutDupes, result.data!];
  });
  ```
  This removes both the optimistic message AND any early-arriving Realtime message with the same server ID, then adds the definitive server message at the end.

**Step 5: Add Realtime subscription useEffect**
After the existing fetch useEffect and after `handleRealtimeMessage`, add a NEW useEffect for the Realtime subscription. Use `useAuth()`'s `tenantId` (already available from the `useAuth` hook — add `tenantId` to the destructure at the top: `const { user, tenantId } = useAuth();`):

```typescript
// Realtime subscription: subscribe when sheet opens, clean up when it closes
useEffect(() => {
  if (!open || !balanceCase?.id || !tenantId) return;

  const channel = balanceChatService.subscribeToBalanceChat(
    tenantId,
    balanceCase.id,
    handleRealtimeMessage
  );

  return () => {
    supabase.removeChannel(channel);
  };
}, [open, balanceCase?.id, tenantId, handleRealtimeMessage]);
```

Critical cleanup: `supabase.removeChannel(channel)` fully removes the channel from the Realtime client (NOT `channel.unsubscribe()` which leaves it in the registry). This matches the ChatPanel.tsx pattern.

**What NOT to do:**
- Do NOT create a Zustand store — useState is sufficient for single-instance panel
- Do NOT add a connection status indicator — that's Phase 10 polish
- Do NOT add `console.warn` for subscribe status — keep it clean for now
- Do NOT use `channel.unsubscribe()` — always use `supabase.removeChannel(channel)`
  </action>
  <verify>
Run `npm run typecheck` — must pass with 0 errors. Run `npm run lint` — no NEW errors in modified files (514 pre-existing is OK). Verify the file contains: (1) `useRef` import, (2) `supabase` import, (3) `userMapRef`, (4) `handleRealtimeMessage` callback, (5) `removeChannel` cleanup, (6) `subscribeToBalanceChat` call, (7) dedup logic in both handleRealtimeMessage and handleSend success path.
  </verify>
  <done>
BalanceChatSheet subscribes to Realtime on sheet open, cleans up on close, deduplicates messages from optimistic send + Realtime race, enriches Realtime messages with sender info from userMap, and properly handles balance switching by re-subscribing via useEffect dependency on balanceCase.id.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with 0 errors
2. `npm run lint` shows no new errors in modified files
3. `balance-chat.service.ts` contains `subscribeToBalanceChat` method with postgres_changes on balance_chat_messages
4. `BalanceChatSheet.tsx` contains Realtime useEffect with `removeChannel` cleanup
5. `BalanceChatSheet.tsx` contains `handleRealtimeMessage` with dedup via `prev.some(m => m.id === rawMsg.id)`
6. `BalanceChatSheet.tsx` `handleSend` success path filters out both optimistic AND Realtime duplicates
7. Channel name pattern: `balance-chat:${tenantId}:${balanceId}`
8. Server-side filter: `tenant_id=eq.${tenantId}` (single column only)
9. Client-side filter: `balance_id === balanceId && !is_deleted`
</verification>

<success_criteria>
- Real-time subscription is created when sheet opens and destroyed when sheet closes
- Incoming Realtime messages are enriched with sender info and appended to the message list
- Duplicate messages are prevented via ID-based dedup (handles both normal flow and race condition)
- Balance switching triggers re-subscription to the new balance's channel
- No memory leaks: channel is fully removed on cleanup via supabase.removeChannel()
</success_criteria>

<output>
After completion, create `.planning/phases/04-real-time-message-delivery/04-01-SUMMARY.md`
</output>
