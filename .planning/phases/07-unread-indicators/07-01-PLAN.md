---
phase: 07-unread-indicators
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/modules/annual-balance/store/annualBalanceStore.ts
  - src/modules/annual-balance/types/annual-balance.types.ts
  - src/modules/annual-balance/pages/AnnualBalancePage.tsx
  - src/modules/annual-balance/components/BalanceTable.tsx
  - src/modules/annual-balance/components/BalanceFilters.tsx
autonomous: true

must_haves:
  truths:
    - "Each balance row shows a red badge with unread count on the chat icon when user has unread messages"
    - "Badge displays '99+' when unread count exceeds 99"
    - "User can toggle a filter to show only balances with unread messages"
    - "Unread badge count updates in real-time when new messages arrive (no page refresh)"
    - "Badge clears immediately when user opens the chat panel (optimistic)"
    - "Unread counts refresh on page mount (handles navigation away and back)"
  artifacts:
    - path: "src/modules/annual-balance/store/annualBalanceStore.ts"
      provides: "unreadCounts map, fetchUnreadCounts, updateUnreadCount, clearUnreadCount actions"
      contains: "unreadCounts"
    - path: "src/modules/annual-balance/types/annual-balance.types.ts"
      provides: "hasUnread field in BalanceFilters interface"
      contains: "hasUnread"
    - path: "src/modules/annual-balance/pages/AnnualBalancePage.tsx"
      provides: "Realtime subscription for tracking table UPDATE events, optimistic badge clear on chat open, client-side hasUnread filter"
      contains: "unread-tracking"
    - path: "src/modules/annual-balance/components/BalanceTable.tsx"
      provides: "Unread badge on MessageCircle icon with 99+ cap"
      contains: "unreadCounts"
    - path: "src/modules/annual-balance/components/BalanceFilters.tsx"
      provides: "Toggle button for unread-only filter"
      contains: "hasUnread"
  key_links:
    - from: "src/modules/annual-balance/pages/AnnualBalancePage.tsx"
      to: "annualBalanceStore.fetchUnreadCounts"
      via: "useEffect on mount"
      pattern: "fetchUnreadCounts"
    - from: "src/modules/annual-balance/pages/AnnualBalancePage.tsx"
      to: "balance_chat_read_tracking Realtime"
      via: "supabase.channel subscription"
      pattern: "unread-tracking"
    - from: "src/modules/annual-balance/pages/AnnualBalancePage.tsx"
      to: "annualBalanceStore.clearUnreadCount"
      via: "handleChatClick callback"
      pattern: "clearUnreadCount"
    - from: "src/modules/annual-balance/components/BalanceTable.tsx"
      to: "unreadCounts prop"
      via: "prop passed from AnnualBalancePage"
      pattern: "unreadCounts\\[row\\.id\\]"
    - from: "src/modules/annual-balance/components/BalanceFilters.tsx"
      to: "hasUnread filter"
      via: "onFiltersChange callback"
      pattern: "hasUnread"
---

<objective>
Add unread message badges to the balance table chat icons, a filter toggle for unread-only balances, and real-time badge updates via Supabase Realtime subscription on the tracking table.

Purpose: Users can immediately see which balances have new messages waiting for them without opening each chat individually, and can filter to focus only on those needing attention.
Output: Unread badges on chat icons, hasUnread filter toggle, Realtime subscription for live updates.
</objective>

<execution_context>
@/Users/asafbenatia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/asafbenatia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-read-tracking/06-01-SUMMARY.md
@.planning/phases/07-unread-indicators/07-RESEARCH.md

Key files to understand before modifying:
@src/modules/annual-balance/store/annualBalanceStore.ts
@src/modules/annual-balance/types/annual-balance.types.ts
@src/modules/annual-balance/pages/AnnualBalancePage.tsx
@src/modules/annual-balance/components/BalanceTable.tsx
@src/modules/annual-balance/components/BalanceFilters.tsx
@src/modules/annual-balance/services/balance-chat.service.ts (for getUnreadCounts/markAsRead signatures)
@src/modules/annual-balance/components/BalanceChatSheet.tsx (for Realtime subscription pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend store with unread counts and add hasUnread to BalanceFilters type</name>
  <files>
    src/modules/annual-balance/store/annualBalanceStore.ts
    src/modules/annual-balance/types/annual-balance.types.ts
  </files>
  <action>
**1. Extend BalanceFilters type** (`annual-balance.types.ts`):
Add `hasUnread?: boolean` to the `BalanceFilters` interface (after `hasTaxCoding`). This is a client-side-only filter field -- it is NOT sent to the server `getAll` query.

**2. Extend annualBalanceStore** (`annualBalanceStore.ts`):

Add to `AnnualBalanceState` interface:
```typescript
// Unread counts: balance_id -> count (only non-zero entries)
unreadCounts: Record<string, number>;
fetchUnreadCounts: () => Promise<void>;
updateUnreadCount: (balanceId: string, count: number) => void;
clearUnreadCount: (balanceId: string) => void;
```

Add import at top:
```typescript
import { balanceChatService } from '../services/balance-chat.service';
```

Add initial state in `create()`:
```typescript
unreadCounts: {},
```

Add three actions in `create()`:

`fetchUnreadCounts`:
- Call `balanceChatService.getUnreadCounts()`
- If `result.data` is truthy, `set({ unreadCounts: result.data })`
- No error toast needed -- badge absence is acceptable fallback

`updateUnreadCount(balanceId, count)`:
- Use `set((state) => { ... })` updater pattern
- Spread `state.unreadCounts` into `updated` object
- If `count > 0`, set `updated[balanceId] = count`
- If `count <= 0`, `delete updated[balanceId]` (remove zero entries to keep map sparse)
- Return `{ unreadCounts: updated }`

`clearUnreadCount(balanceId)`:
- Use `set((state) => { ... })` updater pattern
- Spread `state.unreadCounts` into `updated` object
- `delete updated[balanceId]`
- Return `{ unreadCounts: updated }`

Also update `hasActiveFilters` logic: The `hasUnread` filter should be included in the `hasActiveFilters` check in BalanceFilters (handled in Task 2), but the store `resetFilters` does NOT need changes because `hasUnread` is not in `DEFAULT_FILTERS` -- when filters reset, `hasUnread` will be `undefined` which is correct (filter off).
  </action>
  <verify>
Run `npm run typecheck` -- must pass with no errors. Verify the new state fields exist in the store by checking the file contents.
  </verify>
  <done>
annualBalanceStore has unreadCounts map with fetchUnreadCounts, updateUnreadCount, clearUnreadCount actions. BalanceFilters type has optional hasUnread boolean. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unread badge on chat icon, filter toggle, Realtime subscription, and page wiring</name>
  <files>
    src/modules/annual-balance/pages/AnnualBalancePage.tsx
    src/modules/annual-balance/components/BalanceTable.tsx
    src/modules/annual-balance/components/BalanceFilters.tsx
  </files>
  <action>
**1. Wire unread state and Realtime in AnnualBalancePage.tsx:**

Add imports:
```typescript
import { supabase } from '@/lib/supabase';
```

Destructure new store actions from `useAnnualBalanceStore`:
```typescript
const {
  // ... existing destructured fields ...
  unreadCounts,
  fetchUnreadCounts,
  updateUnreadCount,
  clearUnreadCount,
} = useAnnualBalanceStore();
```

Get `tenantId` from auth context. The `useAuth` hook is already imported -- check if it exposes `tenantId`. If it exposes `user?.user_metadata?.tenant_id`, use that. Otherwise check the pattern in `BalanceChatSheet.tsx` for how `tenantId` is obtained (likely `user?.user_metadata?.tenant_id`).

**Fetch unread counts on mount:** In the existing `useEffect` that calls `fetchCases()` and `fetchDashboardStats()`, also call `fetchUnreadCounts()`:
```typescript
useEffect(() => {
  fetchCases();
  fetchDashboardStats();
  fetchUnreadCounts();
}, [fetchCases, fetchDashboardStats, fetchUnreadCounts]);
```

**Add Realtime subscription for tracking table updates:**
```typescript
useEffect(() => {
  const tenantId = user?.user_metadata?.tenant_id;
  if (!tenantId) return;

  const channel = supabase
    .channel(`unread-tracking:${tenantId}`)
    .on(
      'postgres_changes',
      {
        event: 'UPDATE',
        schema: 'public',
        table: 'balance_chat_read_tracking',
        filter: `tenant_id=eq.${tenantId}`,
      },
      (payload) => {
        const row = payload.new as {
          balance_id: string;
          unread_count: number;
        };
        updateUnreadCount(row.balance_id, row.unread_count);
      }
    )
    .subscribe();

  return () => {
    supabase.removeChannel(channel);
  };
}, [user?.user_metadata?.tenant_id, updateUnreadCount]);
```

**Optimistic badge clear on chat open:**
Update the existing `handleChatClick` callback to also call `clearUnreadCount`:
```typescript
const handleChatClick = useCallback((row: AnnualBalanceSheetWithClient) => {
  setChatBalanceCase(row);
  setChatOpen(true);
  clearUnreadCount(row.id);
}, [clearUnreadCount]);
```

**Client-side hasUnread filter:**
Add a `useMemo` to filter cases when `hasUnread` is active:
```typescript
const filteredCases = useMemo(() => {
  if (!filters.hasUnread) return cases;
  return cases.filter((c) => (unreadCounts[c.id] ?? 0) > 0);
}, [cases, filters.hasUnread, unreadCounts]);
```

Pass `filteredCases` to `BalanceTable` instead of `cases`. Also pass `unreadCounts` as a new prop:
```typescript
<BalanceTable
  cases={filteredCases}
  // ... all existing props ...
  unreadCounts={unreadCounts}
/>
```

**2. Add unread badge to BalanceTable.tsx:**

Add `unreadCounts` prop to `BalanceTableProps`:
```typescript
interface BalanceTableProps {
  // ... existing props ...
  unreadCounts: Record<string, number>;
}
```

Destructure `unreadCounts` from props in the component function.

Replace the existing chat icon Button (lines ~292-301) with a wrapper div that includes the badge:
```tsx
{canAccessBalanceChat(userRole, userId, { auditor_id: row.auditor_id }) && (
  <div className="relative">
    <Button
      variant="ghost"
      size="icon"
      className="h-7 w-7 shrink-0"
      onClick={() => onChatClick(row)}
    >
      <MessageCircle className="h-4 w-4 text-muted-foreground" />
    </Button>
    {(unreadCounts[row.id] ?? 0) > 0 && (
      <span className="absolute -top-1 -end-1 flex h-4 min-w-4 items-center justify-center rounded-full bg-red-500 text-[10px] text-white font-medium px-0.5 pointer-events-none">
        {unreadCounts[row.id] > 99 ? '99+' : unreadCounts[row.id]}
      </span>
    )}
  </div>
)}
```

Key RTL detail: Use `-end-1` (not `-right-1`) for correct RTL positioning. The badge should appear on the leading edge (left side in RTL), which is `-end-1`. Add `pointer-events-none` so clicking the badge area falls through to the button.

**3. Add hasUnread filter toggle in BalanceFilters.tsx:**

Add `MessageCircle` to the lucide-react imports.

Add the toggle button BEFORE the "Show Inactive" checkbox (after the Tax Coding select, before the checkbox div). Place it before the divider or alongside the existing controls:
```tsx
{/* Unread Messages Filter */}
<Button
  variant={filters.hasUnread ? "default" : "outline"}
  size="sm"
  className="h-9 text-sm gap-1.5 rounded-lg"
  onClick={() => onFiltersChange({ hasUnread: filters.hasUnread ? undefined : true })}
>
  <MessageCircle className="h-3.5 w-3.5" />
  הודעות שלא נקראו
</Button>
```

Update `hasActiveFilters` computation to include `hasUnread`:
```typescript
const hasActiveFilters =
  (filters.search && filters.search.trim() !== '') ||
  filters.status ||
  filters.auditor_id ||
  filters.showInactive ||
  filters.hasTaxCoding !== undefined ||
  filters.hasUnread;
```

This ensures the "reset" button appears when the unread filter is active, and `onReset` (which calls `resetFilters()` in the store) will clear it since `DEFAULT_FILTERS` does not include `hasUnread`.
  </action>
  <verify>
1. Run `npm run typecheck` -- must pass with no errors.
2. Run `npm run lint` -- must pass (or have only pre-existing errors, not new ones).
3. Run `npm run build` -- must produce a successful production build.
4. Visually verify: The BalanceTable component receives `unreadCounts` prop. The `MessageCircle` button is wrapped in a `relative` div with the badge span. The `BalanceFilters` has a new button with Hebrew text "הודעות שלא נקראו". The `AnnualBalancePage` has the Realtime subscription useEffect with cleanup.
  </verify>
  <done>
Chat icon in BalanceTable shows red unread badge with count (capped at 99+). BalanceFilters has a toggle button for "הודעות שלא נקראו" filter. AnnualBalancePage fetches initial unread counts on mount, subscribes to Realtime UPDATE events for live badge updates, optimistically clears badge on chat open, and filters cases client-side when hasUnread is active. TypeScript and build pass cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with no new errors
2. `npm run lint` passes (or only pre-existing errors)
3. `npm run build` produces successful production build
4. annualBalanceStore.ts contains: unreadCounts state, fetchUnreadCounts, updateUnreadCount, clearUnreadCount
5. BalanceFilters type has hasUnread optional boolean
6. AnnualBalancePage.tsx has Realtime subscription on balance_chat_read_tracking with tenant_id filter and cleanup
7. AnnualBalancePage.tsx has filteredCases useMemo for client-side hasUnread filter
8. AnnualBalancePage.tsx handleChatClick calls clearUnreadCount optimistically
9. BalanceTable.tsx renders unread badge with -end-1 RTL positioning and 99+ cap
10. BalanceFilters.tsx has "הודעות שלא נקראו" toggle button
</verification>

<success_criteria>
- Balance rows show red badge with unread count on chat icon when user has unread messages
- Badge displays "99+" when count exceeds 99
- User can click "הודעות שלא נקראו" toggle to filter to only unread balances
- Realtime subscription delivers live unread count updates via Supabase postgres_changes on balance_chat_read_tracking
- Badge clears optimistically when chat panel opens
- Unread counts refresh on every page mount
- TypeScript compiles, lint passes, production build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/07-unread-indicators/07-01-SUMMARY.md`
</output>
