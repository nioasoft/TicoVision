---
phase: 09-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/modules/annual-balance/components/ChatNotificationToast.tsx
  - src/modules/annual-balance/pages/AnnualBalancePage.tsx
  - src/modules/annual-balance/services/annual-balance.service.ts
autonomous: true

must_haves:
  truths:
    - "User receives a Sonner toast when a new chat message arrives for any balance they have access to"
    - "Toast shows sender name, client name, and message preview in RTL layout"
    - "Toast does NOT fire for own messages, system messages, or when the chat sheet is open for that balance"
    - "Clicking the toast opens the chat sheet for that balance and clears unread count"
    - "When a balance is assigned to an auditor for the first time, that auditor receives an email via send-letter edge function"
    - "Email contains client name, tax ID, year, and a link to the annual balance page"
    - "Email does NOT fire on re-assignment (only when previous auditor_id was null)"
  artifacts:
    - path: "src/modules/annual-balance/components/ChatNotificationToast.tsx"
      provides: "RTL-aware custom toast component for chat notifications"
      exports: ["ChatNotificationToast"]
    - path: "src/modules/annual-balance/pages/AnnualBalancePage.tsx"
      provides: "Global Realtime subscription for toast notifications + tenant user map ref"
      contains: "chat-notifications"
    - path: "src/modules/annual-balance/services/annual-balance.service.ts"
      provides: "Email notification on first auditor assignment"
      contains: "simpleMode"
  key_links:
    - from: "src/modules/annual-balance/pages/AnnualBalancePage.tsx"
      to: "supabase.channel('chat-notifications:${tenantId}')"
      via: "Realtime postgres_changes INSERT on balance_chat_messages"
      pattern: "chat-notifications"
    - from: "src/modules/annual-balance/pages/AnnualBalancePage.tsx"
      to: "src/modules/annual-balance/components/ChatNotificationToast.tsx"
      via: "toast.custom() rendering ChatNotificationToast"
      pattern: "toast\\.custom"
    - from: "src/modules/annual-balance/services/annual-balance.service.ts"
      to: "send-letter edge function"
      via: "supabase.functions.invoke('send-letter', { body: { simpleMode: true } })"
      pattern: "simpleMode.*true"
---

<objective>
Add toast notifications for new chat messages and email notification on first auditor assignment.

Purpose: Users stay aware of new chat activity across all their balances without needing to check each one. Auditors receive an email when first assigned to a balance so they can begin work.

Output: ChatNotificationToast component, global Realtime subscription in AnnualBalancePage, email send logic in assignAuditor service method.
</objective>

<execution_context>
@/Users/asafbenatia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/asafbenatia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-notifications/09-RESEARCH.md

# Source files to modify/create
@src/modules/annual-balance/pages/AnnualBalancePage.tsx
@src/modules/annual-balance/services/annual-balance.service.ts
@src/modules/annual-balance/components/BalanceChatSheet.tsx
@src/modules/annual-balance/types/annual-balance.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Toast notification component and global Realtime subscription</name>
  <files>
    src/modules/annual-balance/components/ChatNotificationToast.tsx
    src/modules/annual-balance/pages/AnnualBalancePage.tsx
  </files>
  <action>
**1. Create `ChatNotificationToast.tsx`** in `src/modules/annual-balance/components/`:

A small presentational component rendered inside `toast.custom()`. Props:
- `senderName: string` — resolved display name of the message sender
- `clientName: string` — company_name from the balance's client
- `preview: string` — truncated message content (max 60 chars)
- `onDismiss: () => void` — calls `toast.dismiss(id)`
- `onClick: () => void` — opens chat sheet for the balance

Design:
- Root div: `dir="rtl"`, `w-[356px]`, `bg-background border border-border rounded-lg shadow-lg p-3 cursor-pointer hover:bg-muted/50 transition-colors`
- Top row: `MessageCircle` icon (h-3.5 w-3.5 text-primary), sender name (text-sm font-medium truncate), separator dot, client name (text-xs text-muted-foreground truncate)
- Second row: message preview (text-sm text-muted-foreground line-clamp-2)
- Dismiss X button (top-end, `e.stopPropagation()` to prevent onClick)
- Import `MessageCircle` and `X` from `lucide-react`

**2. Add global Realtime subscription in `AnnualBalancePage.tsx`:**

Add these new imports at the top:
- `useRef` (add to existing React import if not already there)
- `{ toast }` from `'sonner'`
- `{ ChatNotificationToast }` from `'../components/ChatNotificationToast'`
- `{ canAccessBalanceChat }` from `'../types/annual-balance.types'`

Add these refs after existing state declarations:
```typescript
// Refs for toast notification subscription (avoid stale closures)
const casesRef = useRef(cases);
casesRef.current = cases;
const chatStateRef = useRef({ open: chatOpen, balanceId: chatBalanceCase?.id });
chatStateRef.current = { open: chatOpen, balanceId: chatBalanceCase?.id };
const tenantUsersRef = useRef<Map<string, string>>(new Map());
```

Add a useEffect to fetch tenant users once on mount for sender name resolution:
```typescript
useEffect(() => {
  const fetchTenantUsers = async () => {
    const { data } = await supabase.rpc('get_users_for_tenant');
    if (data) {
      const map = new Map<string, string>();
      for (const u of data) {
        map.set(u.user_id, u.full_name || u.email);
      }
      tenantUsersRef.current = map;
    }
  };
  fetchTenantUsers();
}, []);
```

Add a second useEffect for the global toast notification Realtime subscription (place it right after the existing unread tracking subscription useEffect):
- Channel name: `chat-notifications:${tenantId}`
- Event: `INSERT` on `balance_chat_messages` table, filter: `tenant_id=eq.${tenantId}`
- In the callback:
  1. Cast `payload.new` to `{ id: string; balance_id: string; user_id: string; content: string; message_type: string; tenant_id: string }`
  2. Skip if `msg.user_id === user.id` (own message)
  3. Skip if `msg.message_type === 'system'` (system messages)
  4. Skip if `chatStateRef.current.open && chatStateRef.current.balanceId === msg.balance_id` (chat already open for this balance)
  5. Find balance case: `casesRef.current.find(c => c.id === msg.balance_id)` — skip if not found
  6. Check access: `canAccessBalanceChat(userRole, user.id, { auditor_id: balanceCase.auditor_id })` — skip if false
  7. Resolve sender name from `tenantUsersRef.current.get(msg.user_id) || 'משתמש'`
  8. Truncate preview: `msg.content.length > 60 ? msg.content.slice(0, 60) + '...' : msg.content`
  9. Fire `toast.custom((id) => <ChatNotificationToast ... />, { duration: 8000 })`
  10. The `onClick` handler: call `setChatBalanceCase(balanceCase)`, `setChatOpen(true)`, `clearUnreadCount(balanceCase.id)`, `toast.dismiss(id)`
- Cleanup: `supabase.removeChannel(channel)`
- Dependencies: `[user?.user_metadata?.tenant_id, user?.id, userRole]` — uses refs for cases and chatState to avoid subscription churn
- Do NOT include `cases`, `chatOpen`, or `chatBalanceCase` in deps (that's why we use refs)

**Important:** The `supabase` import already exists in `AnnualBalancePage.tsx`. The `useRef` import must be added to the existing React import line.
  </action>
  <verify>
Run `npm run typecheck` — no type errors in ChatNotificationToast.tsx or AnnualBalancePage.tsx.
Run `npm run lint` — no lint errors in the new/modified files.
Verify ChatNotificationToast.tsx exports the component.
Verify AnnualBalancePage.tsx has two Realtime subscriptions (unread-tracking + chat-notifications).
  </verify>
  <done>
ChatNotificationToast component exists and renders RTL toast with sender name, client name, preview, dismiss, and click-to-open-chat.
AnnualBalancePage has a global Realtime subscription that fires toast.custom() for new chat messages, skipping own messages, system messages, and messages for the currently open chat balance.
Tenant user map is fetched once on mount for sender name resolution.
  </done>
</task>

<task type="auto">
  <name>Task 2: Email notification on first auditor assignment</name>
  <files>
    src/modules/annual-balance/services/annual-balance.service.ts
  </files>
  <action>
Modify the `assignAuditor()` method in `annual-balance.service.ts` to send an email notification via the `send-letter` edge function when a balance is assigned to an auditor for the first time.

**Step 1: Expand the current record fetch to include `auditor_id`, `client_id`, and `year`.**

Find the existing select in `assignAuditor()`:
```typescript
.select('status')
```
Change to:
```typescript
.select('status, auditor_id, client_id, year')
```

**Step 2: Determine if this is a first assignment.**

After `const currentStatus = current.status as BalanceStatus;`, add:
```typescript
const isFirstAssignment = !current.auditor_id;
```

**Step 3: Expand the existing fire-and-forget IIFE to include email sending.**

The existing IIFE currently:
1. Fetches auditor info via `get_user_with_auth` RPC
2. Sends a system message

Expand it to also:
3. If `isFirstAssignment && auditorEmail` (where `auditorEmail` is from the RPC result `auditorInfo?.[0]?.email`):
   a. Fetch client info: query `clients` table for `company_name, tax_id` where `id === current.client_id`
   b. Build the email:
      - `simpleMode: true`
      - `recipientEmails: [auditorEmail]`
      - `recipientName: auditorDisplayName`
      - `subject`: `תיק מאזן שנתי חדש שויך אליך - ${clientName}`
      - `customText`: Multi-line Hebrew string with greeting, client name, tax ID, year, and a link to `${window.location.origin}/annual-balance`
   c. Call `await supabase.functions.invoke('send-letter', { body: { ... } })`
   d. Log success/failure to console (`console.log` on success, error is already caught by the outer try/catch)

**Complete expanded IIFE:**
```typescript
void (async () => {
  try {
    const { data: auditorInfo } = await supabase.rpc('get_user_with_auth', {
      p_user_id: auditorId,
    });
    const auditorDisplayName = auditorInfo?.[0]?.full_name || auditorInfo?.[0]?.email || '';
    const auditorEmail = auditorInfo?.[0]?.email || '';

    // System message in balance chat (existing)
    balanceChatService.sendSystemMessage(id, `מאזן שויך למבקר ${auditorDisplayName}`);

    // Email notification on FIRST assignment only
    if (isFirstAssignment && auditorEmail) {
      const { data: clientInfo } = await supabase
        .from('clients')
        .select('company_name, tax_id')
        .eq('id', current.client_id)
        .single();

      const clientName = clientInfo?.company_name || '';
      const taxId = clientInfo?.tax_id || '';
      const year = current.year;
      const appUrl = typeof window !== 'undefined' ? window.location.origin : 'https://ticovision.vercel.app';

      await supabase.functions.invoke('send-letter', {
        body: {
          simpleMode: true,
          recipientEmails: [auditorEmail],
          recipientName: auditorDisplayName,
          subject: `תיק מאזן שנתי חדש שויך אליך - ${clientName}`,
          customText: [
            `שלום ${auditorDisplayName},`,
            '',
            'תיק מאזן שנתי חדש שויך אליך:',
            '',
            `לקוח: ${clientName}`,
            `ח.פ./ע.מ.: ${taxId}`,
            `שנת מס: ${year}`,
            '',
            `לצפייה בתיק: ${appUrl}/annual-balance`,
          ].join('\n'),
        },
      });
      console.log(`[assignAuditor] Email sent to ${auditorEmail} for balance ${id}`);
    }
  } catch {
    // Non-critical — silently ignore system message and email failures
  }
})();
```

**Key design decisions:**
- `isFirstAssignment` is captured BEFORE the update (using the pre-update `auditor_id` value), so it correctly detects first vs re-assignment.
- The email is fire-and-forget inside the same IIFE as the system message. If the email fails, the assignment still succeeds.
- `typeof window !== 'undefined'` guard for SSR safety (defensive, not strictly needed in Vite SPA).
- No new imports needed — `supabase` and `balanceChatService` are already imported.
  </action>
  <verify>
Run `npm run typecheck` — no type errors in annual-balance.service.ts.
Run `npm run lint` — no lint errors.
Verify the select now includes `status, auditor_id, client_id, year`.
Verify `isFirstAssignment` is computed before the UPDATE query.
Verify the `send-letter` invocation uses `simpleMode: true`.
Grep for `simpleMode` in the file to confirm it appears exactly once.
  </verify>
  <done>
The assignAuditor method fetches the current auditor_id before updating, computes isFirstAssignment, and sends an email via send-letter edge function (simpleMode: true) only when auditor_id was previously null.
Email contains client name, tax ID, year, and link to annual balance page.
Email sending is fire-and-forget inside the existing IIFE, not blocking the assignment response.
Re-assignments (auditor_id already set) do NOT trigger an email.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with no errors
2. `npm run lint` passes with no new errors (pre-existing errors acceptable)
3. ChatNotificationToast.tsx exists and exports the component
4. AnnualBalancePage.tsx has two Realtime channel subscriptions: `unread-tracking:*` and `chat-notifications:*`
5. AnnualBalancePage.tsx uses refs (casesRef, chatStateRef) to avoid stale closures in the Realtime callback
6. AnnualBalancePage.tsx fetches tenant users on mount for sender name enrichment
7. annual-balance.service.ts assignAuditor method selects `auditor_id` before update
8. annual-balance.service.ts calls `send-letter` with `simpleMode: true` only when `isFirstAssignment` is true
</verification>

<success_criteria>
- Toast notification fires for new chat messages from other users (not own, not system, not for open chat balance)
- Toast shows sender name, client name, and message preview in RTL
- Clicking toast opens chat sheet and clears unread count
- Email sent to auditor on first assignment only (not re-assignment)
- Email contains Hebrew text with client name, tax ID, year, and link
- No new packages installed, no new edge functions deployed
- TypeScript compiles, lint passes
</success_criteria>

<output>
After completion, create `.planning/phases/09-notifications/09-01-SUMMARY.md`
</output>
