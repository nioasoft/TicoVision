---
phase: 05-participant-permissions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260210_bcm_role_aware_rls.sql
  - src/modules/annual-balance/types/annual-balance.types.ts
  - src/modules/annual-balance/components/BalanceChatSheet.tsx
  - src/modules/annual-balance/components/BalanceTable.tsx
autonomous: true

must_haves:
  truths:
    - "Admin users can view and send messages for all balances in their tenant"
    - "Accountant users can view and send messages for all balances in their tenant"
    - "Bookkeeper users can only view and send messages for balances where they are the assigned auditor"
    - "Users without chat access see a Hebrew permission error message instead of chat content"
    - "Chat icon is hidden for bookkeepers on balances they are not assigned to"
  artifacts:
    - path: "supabase/migrations/20260210_bcm_role_aware_rls.sql"
      provides: "Role-aware RLS policies replacing tenant-only policies"
      contains: "bcm_select_by_role"
    - path: "src/modules/annual-balance/types/annual-balance.types.ts"
      provides: "canAccessBalanceChat helper function"
      contains: "canAccessBalanceChat"
    - path: "src/modules/annual-balance/components/BalanceChatSheet.tsx"
      provides: "Permission check before rendering chat content"
      contains: "canAccessBalanceChat"
    - path: "src/modules/annual-balance/components/BalanceTable.tsx"
      provides: "Conditional chat icon based on permission check"
      contains: "canAccessBalanceChat"
  key_links:
    - from: "supabase/migrations/20260210_bcm_role_aware_rls.sql"
      to: "balance_chat_messages RLS policies"
      via: "DROP POLICY + CREATE POLICY replacing bcm_select_own_tenant and bcm_insert_own_tenant"
      pattern: "bcm_select_by_role.*annual_balance_sheets.*auditor_id"
    - from: "src/modules/annual-balance/types/annual-balance.types.ts"
      to: "src/modules/annual-balance/components/BalanceChatSheet.tsx"
      via: "import canAccessBalanceChat"
      pattern: "canAccessBalanceChat.*role.*userId.*balanceCase"
    - from: "src/modules/annual-balance/types/annual-balance.types.ts"
      to: "src/modules/annual-balance/components/BalanceTable.tsx"
      via: "import canAccessBalanceChat"
      pattern: "canAccessBalanceChat.*auditor_id"
---

<objective>
Replace tenant-only RLS policies on balance_chat_messages with role-aware policies (admin/accountant = full tenant access, bookkeeper = assigned balances only), and add client-side permission gating to hide/disable chat for unauthorized users.

Purpose: Enforce CHAT-07 requirement -- chat visibility restricted to assigned auditor, accountants, and admin per balance. Defense-in-depth: RLS is the security boundary, UI gating provides UX.

Output: Migration SQL applied to Supabase, canAccessBalanceChat helper function, conditional chat icon and permission error in chat sheet.
</objective>

<execution_context>
@/Users/asafbenatia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/asafbenatia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-participant-permissions/05-RESEARCH.md
@.planning/phases/01-database-foundation/01-01-SUMMARY.md
@supabase/migrations/20260209_balance_chat_messages.sql
@src/modules/annual-balance/types/annual-balance.types.ts
@src/modules/annual-balance/types/balance-chat.types.ts
@src/modules/annual-balance/components/BalanceChatSheet.tsx
@src/modules/annual-balance/components/BalanceTable.tsx
@src/modules/annual-balance/pages/AnnualBalancePage.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Apply role-aware RLS migration for balance_chat_messages</name>
  <files>supabase/migrations/20260210_bcm_role_aware_rls.sql</files>
  <action>
Create a Supabase migration that replaces the existing tenant-only SELECT and INSERT RLS policies on `balance_chat_messages` with role-aware versions.

**Migration SQL must:**

1. DROP the existing policies:
   - `bcm_select_own_tenant`
   - `bcm_insert_own_tenant`

2. CREATE new SELECT policy `bcm_select_by_role` with USING clause:
   - `is_super_admin(auth.uid())` OR
   - `tenant_id = (select get_current_tenant_id())` AND EXISTS check on `user_tenant_access` where:
     - `uta.user_id = (select auth.uid())`
     - `uta.tenant_id = balance_chat_messages.tenant_id`
     - `uta.is_active = true`
     - AND either:
       - `uta.role IN ('admin', 'accountant')` (full tenant access)
       - OR EXISTS subquery on `annual_balance_sheets` where `abs.id = balance_chat_messages.balance_id AND abs.auditor_id = (select auth.uid())` (bookkeeper assigned auditor check)

3. CREATE new INSERT policy `bcm_insert_by_role` with WITH CHECK clause:
   - Same structure as SELECT policy, plus `user_id = (select auth.uid())` to prevent impersonation (same as original)

**Performance requirements (from research):**
- Wrap `auth.uid()` in `(select auth.uid())` for initPlan caching
- Wrap `get_current_tenant_id()` in `(select get_current_tenant_id())` for initPlan caching
- The `annual_balance_sheets.id` lookup is a PK index scan -- O(1)
- Place `uta.role IN ('admin', 'accountant')` first in the OR for short-circuit optimization

**DO NOT touch** the existing `bcm_update_admin_accountant` policy (UPDATE remains admin/accountant only).

**Apply via** Supabase Management API (same pattern as Phase 1 -- local/remote migration history mismatch). Save the SQL file locally at `supabase/migrations/20260210_bcm_role_aware_rls.sql` for version control.

Use the MCP `apply_migration` tool with name `bcm_role_aware_rls` and the full SQL as query.
  </action>
  <verify>
Run SQL to verify policies exist:
```sql
SELECT policyname, cmd FROM pg_policies WHERE tablename = 'balance_chat_messages';
```
Expected: `bcm_select_by_role` (SELECT), `bcm_insert_by_role` (INSERT), `bcm_update_admin_accountant` (UPDATE). The old `bcm_select_own_tenant` and `bcm_insert_own_tenant` must NOT appear.
  </verify>
  <done>
Old tenant-only SELECT and INSERT RLS policies are replaced with role-aware versions. Admin/accountant get full tenant access. Bookkeeper users can only SELECT/INSERT for balances where they are the assigned auditor. UPDATE policy unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add canAccessBalanceChat helper and UI permission gating</name>
  <files>
    src/modules/annual-balance/types/annual-balance.types.ts
    src/modules/annual-balance/components/BalanceChatSheet.tsx
    src/modules/annual-balance/components/BalanceTable.tsx
  </files>
  <action>
**Part A: Add canAccessBalanceChat helper (annual-balance.types.ts)**

Add to the BALANCE_PERMISSIONS record:
```typescript
view_chat: ['admin', 'accountant', 'bookkeeper'],
send_chat: ['admin', 'accountant', 'bookkeeper'],
```
(Note: bookkeeper access is conditional on auditor_id -- the function below handles this.)

Add a new exported function after `hasBalancePermission`:
```typescript
/**
 * Check if a user can access the balance chat.
 * Admin/accountant: always allowed for any balance in their tenant.
 * Bookkeeper: only if they are the assigned auditor for the balance.
 * All other roles: no access.
 */
export function canAccessBalanceChat(
  role: string,
  userId: string,
  balanceCase: { auditor_id: string | null }
): boolean {
  if (role === 'admin' || role === 'accountant') return true;
  if (role === 'bookkeeper' && balanceCase.auditor_id === userId) return true;
  return false;
}
```

**Part B: Conditional chat icon in BalanceTable.tsx**

Import `canAccessBalanceChat` from `../types/annual-balance.types`.

The BalanceTable already receives `userRole: string` as a prop. It also needs the current user ID. Add `userId: string` to the BalanceTableProps interface.

Wrap the existing MessageCircle button (around line 291-297) in a permission check:
```tsx
{canAccessBalanceChat(userRole, userId, { auditor_id: row.auditor_id }) && (
  <Button
    variant="ghost"
    size="icon"
    className="h-7 w-7 shrink-0"
    onClick={() => onChatClick(row)}
  >
    <MessageCircle className="h-4 w-4 text-muted-foreground" />
  </Button>
)}
```

Update AnnualBalancePage.tsx to pass `userId={user?.id || ''}` to `<BalanceTable>`. The page already imports `useAuth` and has `const { role } = useAuth()` -- destructure `user` as well (it may already be destructured elsewhere; check first).

**Part C: Permission gate in BalanceChatSheet.tsx**

Import `canAccessBalanceChat` from `../types/annual-balance.types`.

The component already has `const { user, tenantId } = useAuth()` -- also destructure `role` from useAuth: `const { user, tenantId, role } = useAuth()`.

Before the main return (the Sheet JSX), add a permission check. If the sheet is open but the user lacks access, render a permission-denied Sheet instead of the chat:

```tsx
const hasAccess = balanceCase
  ? canAccessBalanceChat(role || '', user?.id || '', { auditor_id: balanceCase.auditor_id })
  : false;
```

If `!hasAccess && open`, render:
```tsx
<Sheet open={open} onOpenChange={onOpenChange}>
  <SheetContent side="left" className="w-[400px] sm:max-w-[420px] p-0 flex flex-col" dir="rtl">
    <SheetHeader className="p-4 border-b">
      <SheetTitle className="text-right">שיחה</SheetTitle>
      <SheetDescription className="text-right">
        {balanceCase?.client?.company_name || ''}
      </SheetDescription>
    </SheetHeader>
    <div className="flex-1 flex items-center justify-center p-6 text-center">
      <p className="text-muted-foreground">אין לך הרשאה לצפות בשיחה זו</p>
    </div>
  </SheetContent>
</Sheet>
```

This provides a graceful fallback if the UI gating in BalanceTable is somehow bypassed (e.g., deep link or stale state).

**DO NOT** add a service-layer checkChatAccess method -- the RLS policy is the security boundary and the UI helper is sufficient for UX gating. Service-layer check would be redundant and add an extra DB round-trip.
  </action>
  <verify>
1. `npm run typecheck` passes with 0 errors
2. `npm run lint` shows no new errors in modified files
3. Grep for `canAccessBalanceChat` in types file, BalanceChatSheet, and BalanceTable -- all 3 must contain it
4. Grep for `bcm_select_own_tenant` in BalanceChatSheet -- must NOT appear (old pattern removed)
5. Verify BalanceTable renders MessageCircle conditionally (wrapped in canAccessBalanceChat check)
  </verify>
  <done>
canAccessBalanceChat helper exported from annual-balance.types.ts. Chat icon conditionally rendered in BalanceTable based on role + auditor assignment. BalanceChatSheet shows Hebrew permission error for unauthorized access. TypeScript compiles and lints clean.
  </done>
</task>

</tasks>

<verification>
1. **RLS enforcement**: Run SQL `SELECT policyname, cmd FROM pg_policies WHERE tablename = 'balance_chat_messages'` -- must show bcm_select_by_role, bcm_insert_by_role, bcm_update_admin_accountant (3 policies total, old names gone)
2. **TypeScript**: `npm run typecheck` passes
3. **Lint**: `npm run lint` shows no new errors in modified files
4. **Helper exists**: `grep -r "canAccessBalanceChat" src/modules/annual-balance/` returns hits in types, BalanceChatSheet, BalanceTable
5. **No regression**: `npm run build` succeeds
</verification>

<success_criteria>
- RLS policies on balance_chat_messages enforce role-based access (admin/accountant = full, bookkeeper = auditor_id match only)
- UI hides chat icon for bookkeepers on unassigned balances
- Permission-denied state renders in Hebrew when chat sheet opened without access
- Zero TypeScript errors, zero new lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-participant-permissions/05-01-SUMMARY.md`
</output>
