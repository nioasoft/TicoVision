---
phase: 02-chat-service-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/modules/annual-balance/types/balance-chat.types.ts
  - src/modules/annual-balance/services/balance-chat.service.ts
autonomous: true

must_haves:
  truths:
    - "ChatService extends BaseService and calls getTenantId() on every query"
    - "getMessages(balanceId) returns enriched messages with sender_name and sender_email"
    - "sendMessage(balanceId, content) inserts a row and returns the enriched message"
    - "softDeleteMessage(messageId) sets is_deleted=true without hard deleting"
    - "getMessageCount(balanceId) returns integer count of active messages"
    - "All methods return ServiceResponse<T> and never expose raw database errors"
  artifacts:
    - path: "src/modules/annual-balance/types/balance-chat.types.ts"
      provides: "Type definitions for balance chat messages"
      contains: "BalanceChatMessageWithSender"
    - path: "src/modules/annual-balance/services/balance-chat.service.ts"
      provides: "CRUD operations for balance chat messages"
      exports: ["balanceChatService"]
  key_links:
    - from: "src/modules/annual-balance/services/balance-chat.service.ts"
      to: "src/services/base.service.ts"
      via: "extends BaseService"
      pattern: "class BalanceChatService extends BaseService"
    - from: "src/modules/annual-balance/services/balance-chat.service.ts"
      to: "src/modules/annual-balance/types/balance-chat.types.ts"
      via: "import types"
      pattern: "import.*from.*balance-chat\\.types"
    - from: "src/modules/annual-balance/services/balance-chat.service.ts"
      to: "supabase.from('balance_chat_messages')"
      via: "PostgREST queries"
      pattern: "from\\('balance_chat_messages'\\)"
    - from: "src/modules/annual-balance/services/balance-chat.service.ts"
      to: "supabase.rpc('get_users_for_tenant')"
      via: "RPC call for sender enrichment"
      pattern: "rpc\\('get_users_for_tenant'\\)"
---

<objective>
Create the BalanceChatService class with four CRUD methods and supporting TypeScript types for balance chat messages.

Purpose: Provide the data access layer that Phase 3 (Chat UI) will call for message display and sending. This service wraps Supabase queries with tenant isolation, sender enrichment, soft-delete, and error handling -- all following established BaseService patterns.

Output: Two files -- type definitions and service class with singleton export.
</objective>

<execution_context>
@/Users/asafbenatia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/asafbenatia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-database-foundation/01-01-SUMMARY.md
@.planning/phases/02-chat-service-layer/02-RESEARCH.md

# Codebase references (read these before implementing):
@src/services/base.service.ts
@src/modules/annual-balance/services/annual-balance.service.ts
@src/modules/annual-balance/types/annual-balance.types.ts
@src/types/database.types.ts (lines 344-397 for balance_chat_messages)
@src/services/capital-declaration.service.ts (lines 362-380 for get_users_for_tenant pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create balance chat type definitions</name>
  <files>src/modules/annual-balance/types/balance-chat.types.ts</files>
  <action>
Create `src/modules/annual-balance/types/balance-chat.types.ts` with the following type definitions:

1. **BalanceChatMessageRow** -- Derive from `Database['public']['Tables']['balance_chat_messages']['Row']`. This is the raw DB row type.

2. **BalanceChatMessageInsert** -- Derive from `Database['public']['Tables']['balance_chat_messages']['Insert']`. Used for creating messages.

3. **BalanceChatMessageUpdate** -- Derive from `Database['public']['Tables']['balance_chat_messages']['Update']`. Used for soft-delete updates.

4. **MessageType** -- Literal union type: `'user' | 'system'`. Matches the CHECK constraint on the message_type column.

5. **BalanceChatMessageWithSender** -- Interface extending `BalanceChatMessageRow` with two additional fields:
   - `sender_email: string` (email of the message author)
   - `sender_name: string` (display name of the message author)

Import `Database` from `@/types/database.types`.

Add JSDoc comments (English) on each type explaining its purpose and which service methods use it.

**Do NOT:**
- Import or reference any types from `src/modules/chat/types/chat.types.ts` (that's the channel-based chat, different schema)
- Add any runtime code -- this file is types only
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile without errors. Verify the file exists and exports all 5 types.
  </verify>
  <done>
File `src/modules/annual-balance/types/balance-chat.types.ts` exists, exports BalanceChatMessageRow, BalanceChatMessageInsert, BalanceChatMessageUpdate, MessageType, and BalanceChatMessageWithSender. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BalanceChatService with four CRUD methods</name>
  <files>src/modules/annual-balance/services/balance-chat.service.ts</files>
  <action>
Create `src/modules/annual-balance/services/balance-chat.service.ts` following the BaseService pattern from `annual-balance.service.ts`.

**Class structure:**

```typescript
import { BaseService } from '@/services/base.service';
import type { ServiceResponse } from '@/services/base.service';
import { supabase } from '@/lib/supabase';
import type { BalanceChatMessageWithSender } from '../types/balance-chat.types';
```

Class `BalanceChatService extends BaseService` with `super('balance_chat_messages')` in constructor.

**Method 1: getMessages(balanceId: string, limit?: number)**
- Returns `Promise<ServiceResponse<BalanceChatMessageWithSender[]>>`
- Default limit = 50
- Call `getTenantId()` first
- Query `balance_chat_messages` with `.eq('tenant_id', tenantId)`, `.eq('balance_id', balanceId)`, `.eq('is_deleted', false)`
- Order by `created_at` ascending (oldest first -- chat flows top-to-bottom)
- Apply `.limit(limit)`
- **Sender enrichment**: Call `supabase.rpc('get_users_for_tenant')` to get all tenant users (no args -- RPC uses JWT tenant internally). Build a `Map<string, { email: string; name: string }>` from the result (key = `user_id`, name = `full_name || email`). Map each message row to `BalanceChatMessageWithSender` by looking up `user_id` in the map. If user not found in map, default to empty strings.
- Only call the RPC if there are messages (skip sender enrichment for empty results)
- Catch errors with `this.handleError(error as Error)`

**Method 2: sendMessage(balanceId: string, content: string)**
- Returns `Promise<ServiceResponse<BalanceChatMessageWithSender>>`
- Call `getTenantId()` first
- Get current user via `supabase.auth.getUser()`
- Return error `{ data: null, error: new Error('User not authenticated') }` if no user
- **Validate content**: Trim the content. If `content.trim().length === 0` or `content.trim().length > 5000`, return `{ data: null, error: new Error('Message content must be between 1 and 5000 characters') }`
- Insert into `balance_chat_messages` with `{ tenant_id, balance_id, user_id: user.id, content: content.trim(), message_type: 'user' }`
- Chain `.select().single()` after `.insert()` to get the inserted row back
- Enrich the returned row with current user's info: `sender_email = user.email ?? ''`, `sender_name = user.user_metadata?.full_name || user.email ?? ''`
- Call `this.logAction('send_balance_chat_message', balanceId, { message_id: data.id })`
- Catch errors with `this.handleError(error as Error)`

**Method 3: softDeleteMessage(messageId: string)**
- Returns `Promise<ServiceResponse<null>>`
- Call `getTenantId()` first
- Get current user via `supabase.auth.getUser()`
- Update `balance_chat_messages` with `{ is_deleted: true, deleted_at: new Date().toISOString(), deleted_by: user?.id }` where `.eq('id', messageId)` and `.eq('tenant_id', tenantId)`
- Call `this.logAction('soft_delete_balance_chat_message', messageId)`
- Return `{ data: null, error: null }` on success
- Catch errors with `this.handleError(error as Error)`

**Method 4: getMessageCount(balanceId: string)**
- Returns `Promise<ServiceResponse<number>>`
- Call `getTenantId()` first
- Query `balance_chat_messages` with `.select('*', { count: 'exact', head: true })`, `.eq('tenant_id', tenantId)`, `.eq('balance_id', balanceId)`, `.eq('is_deleted', false)`
- Return `{ data: count ?? 0, error: null }`
- Catch errors with `this.handleError(error as Error)`

**Singleton export:**
```typescript
export const balanceChatService = new BalanceChatService();
```

**JSDoc comments** (English) on the class and each method.

**Do NOT:**
- Use `get_user_with_auth` (buggy pattern in existing chat.service.ts -- use `get_users_for_tenant` instead)
- Skip the `tenant_id` filter even though RLS enforces it (defense-in-depth per project convention)
- Skip `.select()` after `.insert()` (Supabase returns null data without it)
- Filter by `message_type` -- not needed in Phase 2, all messages are 'user' type for now
- Place this service in `src/modules/chat/` or `src/services/` -- it belongs in the annual-balance module
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile without errors. Verify `balanceChatService` is exported. Verify all 4 methods exist: getMessages, sendMessage, softDeleteMessage, getMessageCount. Check that every method calls `getTenantId()` and uses `this.handleError()` in catch blocks.
  </verify>
  <done>
File `src/modules/annual-balance/services/balance-chat.service.ts` exists, exports `balanceChatService` singleton. All 4 methods (getMessages, sendMessage, softDeleteMessage, getMessageCount) are implemented with tenant isolation, proper error handling, sender enrichment via get_users_for_tenant RPC, content validation on send, soft-delete pattern, and audit logging. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npx eslint src/modules/annual-balance/types/balance-chat.types.ts src/modules/annual-balance/services/balance-chat.service.ts` passes with no new errors
3. Both files exist at the correct paths within the annual-balance module
4. `balanceChatService` is importable (grep for `export const balanceChatService`)
5. Every public method calls `getTenantId()` (grep for `getTenantId` -- should appear 4 times, once per method)
6. Sender enrichment uses `get_users_for_tenant` RPC (grep for `get_users_for_tenant` -- should NOT use `get_user_with_auth`)
7. All queries filter by `is_deleted: false` where appropriate (getMessages and getMessageCount)
8. `sendMessage` chains `.select().single()` after `.insert()`
</verification>

<success_criteria>
- ChatService class extends BaseService with `super('balance_chat_messages')`
- All 4 methods enforce tenant isolation via `getTenantId()`
- `getMessages` returns enriched messages with sender_name and sender_email from batch RPC
- `sendMessage` validates content (1-5000 chars), inserts with `.select().single()`, enriches with current user info, logs action
- `softDeleteMessage` updates is_deleted/deleted_at/deleted_by, logs action
- `getMessageCount` returns count of active (non-deleted) messages
- TypeScript compiles cleanly (`npx tsc --noEmit`)
- No new lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-chat-service-layer/02-01-SUMMARY.md`
</output>
