---
phase: 06-read-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260210_balance_chat_read_tracking.sql
  - src/types/database.types.ts
  - src/modules/annual-balance/services/balance-chat.service.ts
  - src/modules/annual-balance/components/BalanceChatSheet.tsx
autonomous: true

must_haves:
  truths:
    - "When user opens a chat panel, their unread count for that balance resets to zero"
    - "When a new message is inserted, unread counters increment for all tracked users except the sender"
    - "Unread count is stored as a denormalized integer column, not calculated via COUNT queries"
    - "Users who have never opened a chat have no tracking row (correct: they are not following that chat)"
  artifacts:
    - path: "supabase/migrations/20260210_balance_chat_read_tracking.sql"
      provides: "Table, indexes, RLS, trigger, Realtime publication"
      contains: "CREATE TABLE balance_chat_read_tracking"
    - path: "src/modules/annual-balance/services/balance-chat.service.ts"
      provides: "markAsRead and getUnreadCounts methods"
      contains: "markAsRead"
    - path: "src/modules/annual-balance/components/BalanceChatSheet.tsx"
      provides: "markAsRead call on sheet open"
      contains: "markAsRead"
    - path: "src/types/database.types.ts"
      provides: "TypeScript types for balance_chat_read_tracking"
      contains: "balance_chat_read_tracking"
  key_links:
    - from: "BalanceChatSheet.tsx"
      to: "balance-chat.service.ts"
      via: "balanceChatService.markAsRead(balanceCase.id) in fetchMessages useEffect"
      pattern: "markAsRead\\(balanceCase"
    - from: "balance-chat.service.ts"
      to: "balance_chat_read_tracking table"
      via: "supabase.from('balance_chat_read_tracking').upsert()"
      pattern: "balance_chat_read_tracking"
    - from: "increment_balance_chat_unread trigger"
      to: "balance_chat_read_tracking table"
      via: "AFTER INSERT trigger on balance_chat_messages updates tracking rows"
      pattern: "trigger_increment_chat_unread"
---

<objective>
Create the read tracking infrastructure for balance chat: a denormalized unread counter table with automatic trigger-based increment on message insert and upsert-based reset on chat open.

Purpose: Enable O(1) unread badge lookups (Phase 7) without COUNT queries, and mark messages as read when users open the chat panel.
Output: Database table + trigger, service methods (markAsRead, getUnreadCounts), UI integration (markAsRead on sheet open).
</objective>

<execution_context>
@/Users/asafbenatia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/asafbenatia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-read-tracking/06-RESEARCH.md
@.planning/phases/01-database-foundation/01-01-SUMMARY.md
@src/modules/annual-balance/services/balance-chat.service.ts
@src/modules/annual-balance/components/BalanceChatSheet.tsx
@src/modules/annual-balance/types/balance-chat.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create balance_chat_read_tracking table with trigger and RLS</name>
  <files>supabase/migrations/20260210_balance_chat_read_tracking.sql</files>
  <action>
Apply a migration via the Supabase MCP `apply_migration` tool (same method as Phase 1 — the project uses Management API for migrations due to local/remote history mismatch). Save the SQL file locally for version control.

The migration must create:

1. **Table `balance_chat_read_tracking`** with columns:
   - `id` UUID PRIMARY KEY DEFAULT gen_random_uuid()
   - `tenant_id` UUID NOT NULL REFERENCES tenants(id)
   - `balance_id` UUID NOT NULL REFERENCES annual_balance_sheets(id) ON DELETE CASCADE
   - `user_id` UUID NOT NULL REFERENCES auth.users(id)
   - `unread_count` INTEGER NOT NULL DEFAULT 0
   - `last_read_at` TIMESTAMPTZ DEFAULT NOW()
   - `created_at` TIMESTAMPTZ DEFAULT NOW()
   - `updated_at` TIMESTAMPTZ DEFAULT NOW()
   - UNIQUE constraint on `(tenant_id, balance_id, user_id)` named `uq_bcrt_tenant_balance_user`

2. **Indexes:**
   - `idx_bcrt_user_unread` on `(tenant_id, user_id) WHERE unread_count > 0` (partial index for badge queries)
   - `idx_bcrt_balance` on `(balance_id)` (for trigger UPDATE performance)

3. **RLS** (ENABLE ROW LEVEL SECURITY):
   - `bcrt_select_own`: SELECT USING `tenant_id = (SELECT get_current_tenant_id()) AND user_id = (SELECT auth.uid())`
   - `bcrt_insert_own`: INSERT WITH CHECK `tenant_id = (SELECT get_current_tenant_id()) AND user_id = (SELECT auth.uid())`
   - `bcrt_update_own`: UPDATE USING `tenant_id = (SELECT get_current_tenant_id()) AND user_id = (SELECT auth.uid())`
   - No DELETE policy (tracking rows should not be deleted by users)

4. **updated_at trigger** using the existing `update_updated_at_column()` function:
   ```sql
   CREATE TRIGGER trigger_bcrt_updated_at
     BEFORE UPDATE ON balance_chat_read_tracking
     FOR EACH ROW
     EXECUTE FUNCTION update_updated_at_column();
   ```

5. **Unread increment trigger function** (SECURITY DEFINER — critical so it can update OTHER users' rows):
   ```sql
   CREATE OR REPLACE FUNCTION increment_balance_chat_unread()
   RETURNS TRIGGER
   LANGUAGE plpgsql
   SECURITY DEFINER
   SET search_path TO 'public', 'pg_temp'
   AS $$
   BEGIN
     UPDATE balance_chat_read_tracking
     SET
       unread_count = unread_count + 1,
       updated_at = NOW()
     WHERE balance_id = NEW.balance_id
       AND tenant_id = NEW.tenant_id
       AND user_id != NEW.user_id;
     RETURN NEW;
   END;
   $$;
   ```

6. **Trigger on balance_chat_messages**:
   ```sql
   CREATE TRIGGER trigger_increment_chat_unread
     AFTER INSERT ON balance_chat_messages
     FOR EACH ROW
     WHEN (NEW.is_deleted = false)
     EXECUTE FUNCTION increment_balance_chat_unread();
   ```

7. **Realtime publication** (needed for Phase 7 live badge updates):
   ```sql
   ALTER PUBLICATION supabase_realtime ADD TABLE balance_chat_read_tracking;
   ```

IMPORTANT design note: The trigger ONLY updates existing rows. It does NOT create new rows for users who haven't opened the chat yet. New tracking rows are created via upsert when `markAsRead` is called (Task 2).
  </action>
  <verify>
Run `npm run generate-types` to regenerate TypeScript types after migration. Verify:
1. `src/types/database.types.ts` contains `balance_chat_read_tracking` with all columns typed
2. `npm run typecheck` passes
3. Query the table via Supabase MCP: `SELECT count(*) FROM balance_chat_read_tracking` returns 0 (empty table created successfully)
4. Verify trigger exists: `SELECT tgname FROM pg_trigger WHERE tgname = 'trigger_increment_chat_unread'`
  </verify>
  <done>
Table `balance_chat_read_tracking` exists with UNIQUE constraint, 2 custom indexes, 3 RLS policies (SELECT/INSERT/UPDATE own rows only), updated_at trigger, unread increment trigger (SECURITY DEFINER) on `balance_chat_messages` INSERT, and Realtime publication membership. TypeScript types regenerated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add markAsRead and getUnreadCounts service methods with UI integration</name>
  <files>
    src/modules/annual-balance/services/balance-chat.service.ts
    src/modules/annual-balance/components/BalanceChatSheet.tsx
  </files>
  <action>
**Part A: Add `markAsRead` method to BalanceChatService** (in `balance-chat.service.ts`)

Add after the existing `subscribeToBalanceChat` method:

```typescript
/**
 * Mark all messages as read for the current user in a specific balance chat.
 * Uses upsert (ON CONFLICT UPDATE) to either create a tracking row (first visit)
 * or reset unread_count to 0 (subsequent visits).
 *
 * Called when BalanceChatSheet opens for a balance.
 *
 * @param balanceId - The balance sheet ID to mark as read
 * @returns null on success, error on failure
 */
async markAsRead(balanceId: string): Promise<ServiceResponse<null>> {
  try {
    const tenantId = await this.getTenantId();
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      return { data: null, error: new Error('User not authenticated') };
    }

    const { error } = await supabase
      .from('balance_chat_read_tracking')
      .upsert(
        {
          tenant_id: tenantId,
          balance_id: balanceId,
          user_id: user.id,
          unread_count: 0,
          last_read_at: new Date().toISOString(),
        },
        { onConflict: 'tenant_id,balance_id,user_id' }
      );

    if (error) throw error;
    return { data: null, error: null };
  } catch (error) {
    return { data: null, error: this.handleError(error as Error) };
  }
}
```

**Part B: Add `getUnreadCounts` method to BalanceChatService** (for Phase 7 badge display)

Add after `markAsRead`:

```typescript
/**
 * Get unread message counts for all balances the current user is tracking.
 * Returns a map of balance_id -> unread_count for balances with count > 0.
 *
 * Designed for Phase 7 badge display in the balance table.
 * Single query, O(1) per badge lookup via the returned map.
 *
 * @returns Record mapping balance_id to unread count (only non-zero entries)
 */
async getUnreadCounts(): Promise<ServiceResponse<Record<string, number>>> {
  try {
    const tenantId = await this.getTenantId();
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return { data: {}, error: null };

    const { data, error } = await supabase
      .from('balance_chat_read_tracking')
      .select('balance_id, unread_count')
      .eq('tenant_id', tenantId)
      .eq('user_id', user.id)
      .gt('unread_count', 0);

    if (error) throw error;

    const counts: Record<string, number> = {};
    for (const row of data ?? []) {
      counts[row.balance_id] = row.unread_count;
    }
    return { data: counts, error: null };
  } catch (error) {
    return { data: null, error: this.handleError(error as Error) };
  }
}
```

**Part C: Call `markAsRead` when BalanceChatSheet opens** (in `BalanceChatSheet.tsx`)

In the existing `fetchMessages` useEffect (the one that fires when `open` and `balanceCase?.id` change), add a `markAsRead` call AFTER messages are loaded and rendered. This minimizes the race condition window (see Research Pitfall 2).

Modify the `fetchMessages` function inside the useEffect to call `balanceChatService.markAsRead(balanceCase.id)` after `setMessages` and `setLoading(false)`:

```typescript
// After setLoading(false), add:
if (!cancelled) {
  balanceChatService.markAsRead(balanceCase.id);
}
```

The call is fire-and-forget (no await needed, no error handling needed for the badge reset). The markAsRead is called regardless of whether messages exist (creates tracking row on first visit).

Do NOT await the markAsRead call -- it should not block the UI. If it fails silently, the only consequence is the badge stays until next visit, which is acceptable.
  </action>
  <verify>
1. `npm run typecheck` passes (service methods use correct types from regenerated database.types.ts)
2. `npm run lint` passes (or only pre-existing errors, no new errors in modified files)
3. Verify service methods are exported: grep for `markAsRead` and `getUnreadCounts` in balance-chat.service.ts
4. Verify UI integration: grep for `markAsRead` in BalanceChatSheet.tsx
5. `npm run build` passes
  </verify>
  <done>
BalanceChatService has `markAsRead(balanceId)` method using upsert to reset unread_count to 0, and `getUnreadCounts()` method returning a balance_id -> count map for badge display. BalanceChatSheet calls `markAsRead` after loading messages when the sheet opens. Both methods follow existing service patterns (getTenantId, getUser, handleError).
  </done>
</task>

</tasks>

<verification>
1. Database: `balance_chat_read_tracking` table exists with correct schema, constraints, indexes, RLS, and triggers
2. Trigger test: Insert a message into `balance_chat_messages` for a balance where a tracking row exists for another user — that user's `unread_count` should increment by 1
3. Service: `markAsRead` upserts tracking row with `unread_count = 0`
4. Service: `getUnreadCounts` returns only non-zero entries
5. UI: Opening BalanceChatSheet triggers `markAsRead` call
6. Build: `npm run build` succeeds
7. Types: `npm run typecheck` passes
</verification>

<success_criteria>
- balance_chat_read_tracking table is live with denormalized unread_count column
- Trigger atomically increments unread_count for tracked users (except sender) on message insert
- markAsRead resets counter to 0 via upsert when chat panel opens
- getUnreadCounts provides O(1) badge data for Phase 7
- No new lint or typecheck errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-read-tracking/06-01-SUMMARY.md`
</output>
