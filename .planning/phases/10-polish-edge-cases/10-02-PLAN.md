---
phase: 10-polish-edge-cases
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/modules/annual-balance/services/balance-chat.service.ts
  - src/modules/annual-balance/components/BalanceChatSheet.tsx
  - src/modules/annual-balance/components/BalanceChatMessages.tsx
autonomous: true

must_haves:
  truths:
    - "User can load 200+ messages by clicking 'load earlier messages' button after initial 100 are loaded"
    - "Long unbroken text (200+ char URLs) wraps inside message bubbles without horizontal scroll"
    - "Timestamps appear at the logical end of each message bubble in RTL context"
    - "Chat panel renders 200 messages smoothly without noticeable lag"
  artifacts:
    - path: "src/modules/annual-balance/services/balance-chat.service.ts"
      provides: "Default limit=100 and offset parameter for pagination"
      contains: "limit: number = 100"
    - path: "src/modules/annual-balance/components/BalanceChatMessages.tsx"
      provides: "Load earlier button, RTL timestamp alignment, overflow-hidden on bubbles"
      contains: "text-end"
    - path: "src/modules/annual-balance/components/BalanceChatSheet.tsx"
      provides: "Load-more handler passing older messages into state"
      contains: "handleLoadEarlier"
  key_links:
    - from: "src/modules/annual-balance/components/BalanceChatMessages.tsx"
      to: "BalanceChatSheet"
      via: "onLoadEarlier + hasMore props"
      pattern: "onLoadEarlier"
    - from: "src/modules/annual-balance/components/BalanceChatSheet.tsx"
      to: "balance-chat.service.ts"
      via: "getMessages with offset"
      pattern: "getMessages.*offset"
---

<objective>
Increase message capacity to 200+ with load-more pagination, harden RTL layout for long text and timestamps.

Purpose: Addresses success criteria 3 (long message RTL wrapping), 4 (200+ message performance), and 5 (RTL timestamp alignment).
Output: Service with 100-message default + offset, "load earlier messages" button, RTL-correct timestamps, overflow-safe bubbles.
</objective>

<execution_context>
@/Users/asafbenatia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/asafbenatia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-polish-edge-cases/10-RESEARCH.md
@.planning/phases/10-polish-edge-cases/10-01-SUMMARY.md
@src/modules/annual-balance/services/balance-chat.service.ts
@src/modules/annual-balance/components/BalanceChatSheet.tsx
@src/modules/annual-balance/components/BalanceChatMessages.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add offset pagination to service and load-earlier handler in BalanceChatSheet</name>
  <files>
    src/modules/annual-balance/services/balance-chat.service.ts
    src/modules/annual-balance/components/BalanceChatSheet.tsx
  </files>
  <action>
**balance-chat.service.ts changes:**

1. Change default limit from 50 to 100:
```typescript
async getMessages(
  balanceId: string,
  limit: number = 100
): Promise<ServiceResponse<BalanceChatMessageWithSender[]>> {
```

2. Add an optional `before` parameter for cursor-based pagination. This fetches messages older than a given timestamp:
```typescript
async getMessages(
  balanceId: string,
  limit: number = 100,
  before?: string
): Promise<ServiceResponse<BalanceChatMessageWithSender[]>> {
```

In the query, add the `before` filter conditionally:
```typescript
let query = supabase
  .from('balance_chat_messages')
  .select('*')
  .eq('tenant_id', tenantId)
  .eq('balance_id', balanceId)
  .eq('is_deleted', false)
  .order('created_at', { ascending: true })
  .limit(limit);

if (before) {
  query = query.lt('created_at', before);
}

const { data, error } = await query;
```

**BalanceChatSheet.tsx changes:**

1. Add `hasMore` state: `const [hasMore, setHasMore] = useState(false);`

2. In the existing `fetchMessages` callback, after getting results, set `hasMore` based on whether exactly `limit` messages were returned:
```typescript
const result = await balanceChatService.getMessages(balanceCase.id);
// ...
if (!result.error && result.data) {
  setMessages(result.data);
  setHasMore(result.data.length >= 100);
  // ... existing userMap logic
}
```

3. Add a `handleLoadEarlier` callback that fetches older messages and prepends them:
```typescript
const handleLoadEarlier = useCallback(async () => {
  if (!balanceCase?.id || messages.length === 0) return;

  const oldestTimestamp = messages[0].created_at;
  const result = await balanceChatService.getMessages(
    balanceCase.id,
    100,
    oldestTimestamp
  );

  if (result.error) {
    toast.error('שגיאה בטעינת הודעות קודמות');
    return;
  }

  if (result.data && result.data.length > 0) {
    setMessages(prev => [...result.data!, ...prev]);
    setHasMore(result.data.length >= 100);
  } else {
    setHasMore(false);
  }
}, [balanceCase?.id, messages]);
```

4. Pass `hasMore` and `onLoadEarlier` to BalanceChatMessages:
```tsx
<BalanceChatMessages
  messages={messages}
  loading={loading}
  currentUserId={user?.id || ''}
  error={error}
  onRetry={fetchMessages}
  hasMore={hasMore}
  onLoadEarlier={handleLoadEarlier}
/>
```

**Important:** When `handleLoadEarlier` prepends older messages, do NOT auto-scroll to bottom (the existing scroll-to-bottom effect triggers on `messages` change). To prevent this, modify the scroll behavior in BalanceChatMessages in Task 2 — only auto-scroll when a NEW message is appended (not when old messages are prepended).
  </action>
  <verify>
Run `npm run typecheck`. Grep for `before` parameter in balance-chat.service.ts getMessages signature. Grep for `handleLoadEarlier` in BalanceChatSheet.tsx. Grep for `limit: number = 100` in service.
  </verify>
  <done>
Service fetches 100 messages by default with cursor-based pagination support. BalanceChatSheet manages hasMore state and provides a load-earlier callback. Messages prepend correctly without duplication.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add load-earlier button, fix RTL timestamps, guard long text overflow in BalanceChatMessages</name>
  <files>
    src/modules/annual-balance/components/BalanceChatMessages.tsx
  </files>
  <action>
**BalanceChatMessages.tsx changes:**

1. Extend the props interface:
```typescript
interface BalanceChatMessagesProps {
  messages: BalanceChatMessageWithSender[];
  loading: boolean;
  currentUserId: string;
  error?: string | null;
  onRetry?: () => void;
  hasMore?: boolean;
  onLoadEarlier?: () => void;
}
```

2. Add error state rendering (before loading check). Import `AlertCircle`, `RefreshCw` from `lucide-react`, and `Button` from `@/components/ui/button`:
```tsx
if (error) {
  return (
    <div className="flex-1 flex flex-col items-center justify-center gap-3 p-4 text-center">
      <AlertCircle className="h-8 w-8 text-destructive/70" />
      <p className="text-sm text-destructive">{error}</p>
      {onRetry && (
        <Button variant="outline" size="sm" onClick={onRetry}>
          <RefreshCw className="h-3.5 w-3.5 me-1.5" />
          נסה שוב
        </Button>
      )}
    </div>
  );
}
```

3. Add "load earlier messages" button at the TOP of the message list (inside the scrollable div, before messages.map):
```tsx
{hasMore && onLoadEarlier && (
  <div className="flex justify-center py-2">
    <Button variant="ghost" size="sm" onClick={onLoadEarlier} className="text-xs text-muted-foreground">
      טען הודעות קודמות
    </Button>
  </div>
)}
```

4. Fix auto-scroll to only trigger on NEW messages (appended), not prepended old messages. Change the scroll logic:
```typescript
const prevMessageCountRef = useRef(0);

useEffect(() => {
  // Only auto-scroll when messages are appended (new message at end)
  // Not when prepended (load earlier) — detected by count increase with same last message
  if (messages.length > prevMessageCountRef.current) {
    const lastMsg = messages[messages.length - 1];
    const prevLastMsg = prevMessageCountRef.current > 0 ? messages[prevMessageCountRef.current - 1] : null;
    // If the last message changed, a new message was appended → scroll
    if (!prevLastMsg || lastMsg?.id !== prevLastMsg?.id) {
      bottomRef.current?.scrollIntoView({ behavior: 'smooth' });
    }
  }
  prevMessageCountRef.current = messages.length;
}, [messages]);
```

Actually, simpler approach: track the last message ID. If the last message ID changes, scroll to bottom. If it stays the same (messages were prepended), don't scroll:
```typescript
const lastMsgIdRef = useRef<string | null>(null);

useEffect(() => {
  const currentLastId = messages.length > 0 ? messages[messages.length - 1].id : null;
  if (currentLastId && currentLastId !== lastMsgIdRef.current) {
    bottomRef.current?.scrollIntoView({ behavior: 'smooth' });
  }
  lastMsgIdRef.current = currentLastId;
}, [messages]);
```

5. Add `text-end` class to timestamp `<p>` elements for RTL-correct positioning:
Change:
```tsx
<p className={cn(
  'text-[10px] mt-1',
  isOwn ? 'opacity-70' : 'text-muted-foreground'
)}>
```
To:
```tsx
<p className={cn(
  'text-[10px] mt-1 text-end',
  isOwn ? 'opacity-70' : 'text-muted-foreground'
)}>
```

6. Add `overflow-hidden` to the outer bubble wrapper div to prevent long unbroken text from causing horizontal scroll. Change:
```tsx
<div
  className={cn(
    'max-w-[75%] rounded-lg px-3 py-2 text-sm',
    ...
  )}
>
```
To:
```tsx
<div
  className={cn(
    'max-w-[75%] rounded-lg px-3 py-2 text-sm overflow-hidden',
    ...
  )}
>
```

The `overflow-hidden` combined with the existing `break-words` on the `<p>` element ensures that even extremely long unbroken strings (200+ char URLs) are clipped within the bubble boundary rather than causing horizontal scroll on the message container.

7. Destructure the new props: `{ messages, loading, currentUserId, error, onRetry, hasMore, onLoadEarlier }`
  </action>
  <verify>
Run `npm run typecheck`. Run `npm run lint` on the modified file. Grep for `text-end` in BalanceChatMessages.tsx. Grep for `overflow-hidden` in the bubble div. Grep for `onLoadEarlier` in BalanceChatMessages.tsx. Grep for `AlertCircle` import.
  </verify>
  <done>
Messages component shows error state with retry. "טען הודעות קודמות" button appears at top when more messages exist. Timestamps align to logical end in RTL. Long unbroken text does not cause horizontal scroll. Auto-scroll only fires for new messages, not when loading earlier messages.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors
2. `npm run lint` shows no new errors in modified files
3. `npm run build` succeeds
4. Service default limit is 100 (grep confirms `limit: number = 100`)
5. "Load earlier" button renders when hasMore=true
6. Timestamps have `text-end` class
7. Bubble wrapper has `overflow-hidden`
8. Auto-scroll only triggers on appended messages, not prepended
</verification>

<success_criteria>
- Initial load fetches up to 100 messages (doubled from 50)
- "Load earlier" button fetches next 100 older messages when clicked
- Combined capacity supports 200+ messages in a single balance chat
- Long URLs/text wrap within message bubbles without horizontal overflow
- Timestamps are positioned at the logical end of bubbles in RTL context
- Scrolling to bottom only happens for new incoming messages, not when loading history
</success_criteria>

<output>
After completion, create `.planning/phases/10-polish-edge-cases/10-02-SUMMARY.md`
</output>
